name: MyST GitHub Pages Deploy

on:
  workflow_dispatch:

env:
  BASE_URL: /${{ github.event.repository.name }}
  JUPYTER_BASE_URL: "http://localhost:9090"
  JUPYTER_TOKEN: "1234"

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  deploy:
    if: github.ref == 'refs/heads/main'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends build-essential nodejs npm python3-full
          sudo apt-get install -y --no-install-recommends gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget
          cat .binder/apt.txt | xargs sudo apt-get install -y --no-install-recommends

      - name: Install uv and create virtual environment
        run: |
          curl -fsSL https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          ~/.local/bin/uv venv .venv
          echo "VIRTUAL_ENV=$PWD/.venv" >> $GITHUB_ENV
          echo "$PWD/.venv/bin" >> $GITHUB_PATH

      - name: Setup Pages
        uses: actions/configure-pages@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: Install Node.js packages
        run: npm install --force

      - name: Build components
        run: node build-components.mjs

      - name: Create HTML-to-PNG conversion script
        run: |
          cat > html-to-png.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const puppeteer = require('puppeteer');

          // Directory where components are stored
          const componentsDir = path.join(__dirname, '_components');
          // Directory for PNG output
          const pngDir = path.join(__dirname, 'assets/components');
          
          // Create PNG directory if it doesn't exist
          if (!fs.existsSync(pngDir)) {
            fs.mkdirSync(pngDir, { recursive: true });
          }

          async function convertHtmlToPng() {
            console.log('Starting HTML to PNG conversion...');
            
            // Get all HTML files in components directory
            const htmlFiles = fs.readdirSync(componentsDir)
              .filter(file => file.endsWith('.html'));
              
            console.log(`Found ${htmlFiles.length} HTML components to convert`);
            
            // Launch a headless browser
            const browser = await puppeteer.launch({
              headless: 'new',
              args: ['--no-sandbox', '--disable-setuid-sandbox']
            });
            
            for (const file of htmlFiles) {
              const htmlPath = path.join(componentsDir, file);
              const componentName = file.replace('.html', '');
              const pngPath = path.join(pngDir, `${componentName}.png`);
              
              console.log(`Converting ${file} to PNG...`);
              
              try {
                // Read HTML content
                const htmlContent = fs.readFileSync(htmlPath, 'utf8');
                
                // Create a new page
                const page = await browser.newPage();
                
                // Set viewport size
                await page.setViewport({
                  width: 1200,
                  height: 800,
                  deviceScaleFactor: 2 // Higher resolution
                });
                
                // Set content and wait for rendering
                await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
                
                // Get content size
                const dimensions = await page.evaluate(() => {
                  const element = document.body;
                  return {
                    width: element.scrollWidth,
                    height: element.scrollHeight
                  };
                });
                
                // Resize viewport to fit content
                await page.setViewport({
                  width: dimensions.width,
                  height: dimensions.height,
                  deviceScaleFactor: 2
                });
                
                // Take screenshot
                await page.screenshot({
                  path: pngPath,
                  fullPage: true,
                  omitBackground: false
                });
                
                console.log(`Created ${pngPath}`);
                
                // Close the page
                await page.close();
                
              } catch (error) {
                console.error(`Error converting ${file}:`, error);
              }
            }
            
            // Close the browser
            await browser.close();
            console.log('HTML to PNG conversion completed');
            
            // Now update markdown files to use PNG images instead of include-html
            updateMarkdownFiles();
          }

          function updateMarkdownFiles() {
            console.log('Updating markdown files...');
            
            // Find all markdown files
            const mdFiles = [
              'iceberg-prediction-whitepaper-v2.md',
              'hyperparameter-optimization-whitepaper.md'
            ];
            
            for (const mdFile of mdFiles) {
              if (!fs.existsSync(mdFile)) {
                console.log(`File ${mdFile} not found, skipping.`);
                continue;
              }
              
              console.log(`Processing ${mdFile}...`);
              let content = fs.readFileSync(mdFile, 'utf8');
              
              // Find all include-html directives
              const includeHtmlRegex = /```{include-html} ([A-Za-z0-9_]+)\n\n```/g;
              let match;
              
              while ((match = includeHtmlRegex.exec(content)) !== null) {
                const componentName = match[1];
                const replacement = `![${componentName}](/assets/components/${componentName}.png)`;
                
                // Replace the directive with an image reference
                content = content.replace(match[0], replacement);
                console.log(`Replaced ${componentName} with PNG reference`);
              }
              
              // Fix code blocks with no language specified
              content = content.replace(/```\n/g, '```python\n');
              content = content.replace(/```\s+/g, '```python\n');
              
              // Fix special characters for Typst
              content = content.replace(/\*([^*\n]+)\*/g, '**$1**');
              
              // Write the updated content back
              fs.writeFileSync(mdFile, content);
              console.log(`Updated ${mdFile}`);
            }
            
            console.log('Markdown updates completed');
          }

          // Run the conversion
          convertHtmlToPng().catch(error => {
            console.error('Conversion failed:', error);
            process.exit(1);
          });
          EOF

      - name: Run HTML-to-PNG conversion
        run: |
          node html-to-png.js

      - name: Create separate PDF-friendly versions of markdown
        run: |
          cat > prepare-pdf-content.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          // List of markdown files to process
          const mdFiles = [
            'iceberg-prediction-whitepaper-v2.md',
            'hyperparameter-optimization-whitepaper.md'
          ];

          for (const mdFile of mdFiles) {
            if (!fs.existsSync(mdFile)) {
              console.log(`File ${mdFile} not found, skipping.`);
              continue;
            }

            console.log(`Creating PDF-friendly version of ${mdFile}...`);
            const content = fs.readFileSync(mdFile, 'utf8');
            
            // Create PDF-specific filename
            const pdfMdFile = mdFile.replace('.md', '-pdf.md');
            
            // Copy original content
            let pdfContent = content;
            
            // Update image paths to be absolute
            pdfContent = pdfContent.replace(/!\[(.*?)\]\((\/assets\/.*?)\)/g, '![$1](./$2)');
            
            // Fix other potential Typst rendering issues
            // Remove HTML blocks that might cause problems
            pdfContent = pdfContent.replace(/<div.*?>.*?<\/div>/gs, '');
            
            // Clean up any remaining HTML tags
            pdfContent = pdfContent.replace(/<[^>]*>/g, '');
            
            // Make sure code blocks have language specifiers
            pdfContent = pdfContent.replace(/```\n/g, '```python\n');
            pdfContent = pdfContent.replace(/```\s+/g, '```python\n');
            
            // Fix emphasis markers for Typst
            pdfContent = pdfContent.replace(/\*([^*\n]+)\*/g, '**$1**');
            
            // Write the PDF-specific content
            fs.writeFileSync(pdfMdFile, pdfContent);
            console.log(`Created ${pdfMdFile}`);
            
            // Update the frontmatter in the original file to point to the PDF-specific file
            let updatedContent = content;
            if (updatedContent.includes('exports:')) {
              // Update the PDF export to use the PDF-specific file
              updatedContent = updatedContent.replace(
                /(exports:[\s\S]*?format: pdf[\s\S]*?template: [^\n]*\n)/,
                `$1    source: ${pdfMdFile}\n`
              );
              
              fs.writeFileSync(mdFile, updatedContent);
              console.log(`Updated export configuration in ${mdFile}`);
            }
          }
          EOF

          node prepare-pdf-content.js

      - name: Install Python dependencies
        run: |
          uv pip install -r .binder/requirements.txt

      - name: Install Typst
        run: |
          curl -L -o typst.tar.xz \
            https://github.com/typst/typst/releases/latest/download/typst-x86_64-unknown-linux-musl.tar.xz
          tar -xf typst.tar.xz
          sudo mv typst-x86_64-unknown-linux-musl/typst /usr/local/bin/

      - name: Prepare directories
        run: |
          mkdir -p exports
          mkdir -p assets/components

      - name: Start Jupyter server
        run: |
          # Start Jupyter server in background
          jupyter-server --allow-root --ip 0.0.0.0 --port 9090 --IdentityProvider.token='1234' --ServerApp.allow_origin='*' &
          
          # Wait for server to start
          sleep 10
          
          # Test if server is running
          curl -s --head --request GET http://localhost:9090/api?token=1234 | head -n 1
          
          echo "JUPYTER_BASE_URL: $JUPYTER_BASE_URL"
          echo "JUPYTER_TOKEN: $JUPYTER_TOKEN"
        env:
          JUPYTER_BASE_URL: "http://localhost:9090"
          JUPYTER_TOKEN: "1234"

      - name: Build HTML documentation
        run: |
          # Build HTML separately to ensure proper execution and HTML component inclusion
          myst build --site --execute -d
        env:
          JUPYTER_BASE_URL: "http://localhost:9090"
          JUPYTER_TOKEN: "1234"

      - name: Build PDF documentation
        run: |
          # Build PDFs separately with Typst
          myst build --pdf --typst -d
        env:
          JUPYTER_BASE_URL: "http://localhost:9090"
          JUPYTER_TOKEN: "1234"

      - name: Ensure PDFs are in HTML output
        run: |
          mkdir -p _build/html/exports
          
          # Copy PDFs from exports if they exist
          if [ -d "exports" ] && [ "$(ls -A exports 2>/dev/null)" ]; then
            cp -v exports/*.pdf _build/html/exports/ 2>/dev/null || echo "No PDFs in exports directory"
          fi
          
          # Also look for PDFs in _build directory
          find _build -name "*.pdf" -exec cp -v {} _build/html/exports/ \; 2>/dev/null || echo "No PDFs in _build subdirectories"

      - name: Copy assets to HTML output
        run: |
          # Copy assets directory if it exists
          if [ -d "assets" ]; then
            cp -Rv assets _build/html/assets
          fi
          
          # Copy any other static directories
          for dir in images img static js css fonts; do
            if [ -d "$dir" ]; then
              cp -Rv $dir _build/html/$dir
            fi
          done

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: _build/html

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
